REACT
What is: open-source JavaScript library for building user interfaces, created by Facebook.
What does: create components, handle state and props, utilize event listeners and certain life cycle methods to update data as it changes

Allows to write HTML directly within JavaScript, using an extension of JavaScript called JSX. JSX is similar to HTML. JSX has to be compiled into JavaScript – Babel is a popular tool.

const JSX = (
  <div>
    <p>This is a paragraph. JSX must return only one element, in this case, the parent div.</p>
  <div>)

RENDER HTML ELEMENTS TO THE DOM
We can render elements directly to the HTML DOM using React's rendering API - ReactDOM.

ReactDOM.render(componentToRender, targetNode)


JAVASCRIPT WITHIN JSX
{ 'write code here' }


COMMENTS
{ /* */ }

DIFFERENCES BETWEEN JSX AND HTML
All HTML attributes and event references become camelCase.
class → className
onclick → onClick

In JSX, all tags must have a closing tag. Any element can be writing with a self-closing tag.
<br />
<div />
<div></div>
<CustomComponent />

INLINE STYLES
You can use a external stylesheet, but you can also use inline styles. That is quite common in React development.
  Properties are CamelCase, and the style attribute has to equal to a JavaScript object. All property value lenght unis are assumed to be px unsless otherwise specified. You can use an object to hold the styles.
	<div style={{color: "yellow", fontSize: 16}}>Mellow Yellow</div>


=====================================================
CREATING COMPONENTS
Everything in React is a component.
Stateless component → one that can receive data and render it, but does not manage or track changes to that data.

  STATELESS FUNCTIONAL COMPONENT
  Created by using a JavaScript function that returns either JSX or null. The name must begin with a capital letter.
	const DemoComponent = () => {
	  return (
	    <div className='customClass' />
	  );
	};

  ES6 CLASS COMPONENT
  Class that extends React.Component. The class will have access to many useful React features. It's best practice to call a component's constructor with super, and pass props to both.
	class Kitten extends React.Component {
	  constructor(props) {
	    super(props);
	  }
	  render() {
	    // can write JavaScript code here
	    return <h1>Hi</h1>;
	  }
	}

=======================
COMPOSITION
Separating the UI code from the code responsible for handling the app logic is helpful. You can break down your UI into its basic bulding blocks, and those pieces become the components.
To compose these components together, you need to create an parent component, which renders each of those components. For that, you need to use a custom HTML tag in the JSX with the same name as each component.
return (
  <App>
    <Navbar />
    <Dashboard />
    <Footer />
  </App>
)

=======================
RENDERING A COMPONENT
You use the same syntax for both ES6 class and functional components.
ReactDOM.render(<ComponentToRender />, targetNode);

=======================
PASSING PROPS
You can pass properties to child components.

Passing the custom value:
  <App>
    <Welcome user='Mark' />
  </App>

To access this value:
  STATELESS FUNCTIONAL COMPONENT
    const Welcome = (props) => <h1>Hello, {props.user}</h1>

  ES6 CLASS COMPONENT
    { this.props.propName }

Using Default Props:
  MyComponent.defaultProps = { propName: 'default value of the prop' }
The default prop value is only used if other isn't specified.

Defining the Props you expect:
 MyComponent.propTypes = { propName: PropTypes.func.isRequired }
	func → checks if Prop is an function. Only function (func) and boolean (bool) use unusual spelling. There are other types available.
	isRequired → tells React the Prop is required
As of React v15.5.0, PropTypes is imported independently from React (import PropTypes form 'prop-types';).

=======================
STATE
State consists of any data your application needs to know about, that can change over time. It allows you to track important data in your app and render a UI in response to changes in this data. The state object can be as complex or as simple as you need it to be.
When the state data updates, it triggers a re-render of the component using that data. React updates the actual DOM, but only where necessary.

Creating a stateful compoment:
  Declare a state property in the component's constructor. The state property must be set to a JavaScript object.
	constructor(props) {
	  super(props)
	  this.state = { //state }
	}

Access state data:
  { this.state.propName }

Setting the state value:
  It's done by using this.setState(), passing in an object with key-value pairs. React may batch multiple updates in order to improve performance, meaning state updates using this method can be asynchronous. There is an alternative syntax in order to avoid this.
	this.setState({ username: 'Lewis' })

  KNOWING THE PREVIOUS STATE
    Because the state update may be asynchronous, this.state is not reliable to get the previous value. So you pass arguments with setState:
	this.setState((state, props) => ({
	  counter: state.counter + props.increment
	}));
    Props argument is opcional, if you don't need it you can only pass state.

Pass State as Props to Child Components:
  A commom pattern is to have a stateful component containing the state important to your app, that then renders child components. You only pass the information important to that child component.
  This shows two important paradigms in React:
	→ unidirectional data flow;
	→ complex stateful apps can be broken down into just a few, or maybe a single, stateful component.

=======================
LIFECYCLE METHODS
  Lifecycle methods, or lifecycle hooks → special methods that allow you to perform actions at certain points in time.

componentWillMount()
  Note: will be deprecated in future version 16.X and removed in version 17.
  Called before the render() method when a component is being mounted to the DOM.

componentDidMount()
  Called after a component is mounted to the DOM. This is where you should place API calls or any calls to your server. Any calls to setState() here will trigger a re-rendering of the component. Also the best place to attach any event listeners you need to add for specific functionality.
  Note: React provides a synthetic event system which wraps the native event system present in browsers. It's great for most interactions you'll manage on DOM elements. However, if you want to attach an event handler to the document or window objects, you have to do this directly.

shouldComponentUpdate()
  Called when child components receive new state or props. You can declare specifically if components should update or not. It's a useful way to optimize performance.
	Args: nextProps, nextState
	Return: boolean, tells React if component should update or not

componentDidUpdate()
componentWillUnmount()
  It's good practice to use this method to clean up on React components before they are unmounted and destroyed. Removing event listeners is an example.

=======================
CONDITIONALLY RETURN ELEMENTS
{condition && <p>markup</p>}
  If the condition is true the markup will be returned. If the condition is false, the operation will immediately return false and return nothing. Allows you to handle complex conditional logic in your render() method without repeating a lot of code.

condition ? expressionIfTrue : expressionIfFalse
  Ternary expressions can also be used.

Because of the way JSX is compiled, if/else statements can't be inserted directly into JSX code. You have to used them outside of the return statement.

=======================
Render React on the Server with renderToString
  You can run JavaScript on a Node server, therefore you can also run React code. Without doing this, the app would consist of a relatively empty HTML file and a large bundle of JavaScript when it's initially loaded to the browser.
	→ this is not ideal to search engines trying to index the content of your page;
	→ by doing it, creates a faster initial page load experience.
  React will still be able to recognize your app and manage it after the inital load.

	ReactDOMServer.renderToString(<App />)


=====================================================================
REDUX
Redux is a state management framework. Can be used with different web tecnologies, including React.

There is a single state object that is responsible for the entire state of your application, housed in the Redux store. The Redux store is the single source of truth when it comes to application state. Any time a piece of your app wants to update its state, it must do so through the Redux store.
The methods are available from a Redux object.

CREATE THE REDUX STORE
  Redux.createStore(reducer-function)
  
REDUCER FUNCTION
It's responsible for the state modifications that take place in response to actions. The reducer is a pure function that takes state and action, then returns a new state.
Args: state, action
Return: state
Tips: You can use a switch statement to manage different action types.

  REDUCER FUNCTION & STATE
  State is read-only. So the reducer function must always return a new copy of state and never modify state directly. However Redux does not enforce state immutability, so you are responsible for it.

  REDUCER COMPOSITION
  Typically, it is a good practice to create a reducer for each piece of application state when they are distinct in some way (e.g. authentication and handling user input).
	Redux.combineReducers({
	  key: reducer,
	  ...	
	})
  Args: object in which you define properties which associate keys to specific reducer functions. The name you give to the keys will be used by Redux as the name for the associated piece of state.

STATE
Retrieve the current state held in the Redux store.
  store.getState()

ACTIONS
All state updates are triggered by dispatching actions.
Action → JavaScript object containing information about an action event. It has to have a property called "type", and it can also contain data.
  let action = { type: 'LOGIN', ... }
Action creators → JavaScript function that returns an action. This is what you send to the Redux store.

  DISPACTING AN ACTION
  Dispaches actions to the Redux store.
    store.dispatch(actionCreator())
    store.dispatch({ type: 'LOGIN' })
  
  ACTIONS TYPES AS CONST
  It's common practice with Redux to assign action types as read-only constants, then reference these constants whenever they are used.

STORE LISTENER
Allows you to subscribe listener functions to the store, which are called whenever an action is dispatched against the store.
  store.subscribe(function-callback)

HANDLE ASYNCHRONOUS ACTIONS WITH MIDDLEWARE
  Redux provides middleware designed to handle asynchronous endpoints, called Redux Thunk middleware.

  To include it: when creating the store, pass the applyMiddleware function.
	const store = Redux.createStore(reducer-function, Redux.applyMiddleware(ReduxThunk.default));

  To create an asynchronous function: return a function in the action creator that takes dispatch as an argument. Within it, you can dispatch actions and perform asynchronous requests.
	function handleAsync() {
	  return function(dispatch) {
	    //perform requests here
	    dispatch(receivedData(data))
	  }
	}

  Notes: it's common practice to dispatch an action before initiating any asynchronous behaviour so that the application state knows some data is being requested.


=====================================================================
REACT REDUX APP
You create a sigle Redux store that manages the state of your entire app. Your React components subscribe to only the pieces of data in the store that are relevant to their role. Then, you dispatch actions directly from React components, which then trigger store updates. There are exceptions when individual components may have local state specific only to them.
You need to use the react-redux package, because Redux is not designed to work with React out of the box. It provides a way for you to pass Redux state and dispatch to your React components as props.

PROVIDER
Is a wrapper component from React Redux that wraps your React app. Allows you to access the Redux store and dispatch functions throughout your component tree.
	const Provider = ReactRedux.Provider;
	<Provider store={store}>
		<App/>
	</Provider>

You must specify what state and actions you want. Two functions to accomplish this: mapStateToProps() and mapDispatchToProps(). Behind the scenes, React Redux uses the store.subscribe() method to implement mapStateToProps().

	mapStateToProps()
		args: state
		return: object { messages: state }

	mapDispatchToProps()
		args: dispatch
		return: object { prop-name: function() { dispatch(action-function()) } }

CONNECT
const connect = ReactRedux.connect;

args: mapStateToProps(), mapDispatchToProps() [opt]
	They are optional because you may have a compoment that only needs access to state but doesn't need to dispatch any actions, or vice versa. To omit, pass null in its place.

	const ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(MyComponent)

=======================
Component named Presentation → generally refers to React components that are not directly connected to Redux. They are simply responsible for the presentation of UI.
Component named Container → typically resposible for dispatching actions to ther store and often pass store state to child components as props. Created as constants with the connect() function.

=======================
The state and the dispatch function is available through this.props. For simple apps you can just use React, but as the app grows and becames more complex, so does your state management. This is the problem Redux solves.



=====================================================================
If you are working with npm anda file system on your own machine the code is similar to this, except for the use of import statements.
	import React from 'react'
	import ReactDOM from 'react-dom'
	import { Provider, connect } from 'react-redux'
	import { createStore, combineReducers, applyMiddleware } from 'redux'
	import thunk from 'redux-thunk'

Writing React and Redux code generally requires some configuration. If you are interestend in experimenting on your own machine, the Create React App (https://github.com/facebookincubator/create-react-app) comes configuerd and ready to go.
Alternively you can enable Babel as a JavaScript Preprocessor in CodePen, add React and ReactDOM as external JavaScript resourses, and work there as well.

=====================================================================

REACT HOOKS
useNameHook → the standard is to name the hook with use + name of the component
