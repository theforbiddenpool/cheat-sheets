'use strict' → enables Strict Mode, which catches common coding mistakes and "unsafe" actions.

falsy values → false, 0, "", NaN, undefined, null

() => {} → arrow function
() => 'value' → instead return value

function greeting(name = 'Anonymous') {} → default parameter

function howMany(...args) {} → rest operator, the function can take variable amount of arguments. They will be stored in an array.

Destructuring assignment → special syntax for neatly assigning values taken directly from an object to variables.
	const { x, y, z } = voxel;
	OR const { x: a, y: b, z: c } = voxel; // can be read as copy value form x to a

  Can be used in variables too:
	const [a, b] = [1, 2, 3];
	const [c, d,,, e] = [1, 2, 3, 4, 5, 6];
	const [a, b, ...arr] = [1, 2, 3, 4, 5];

  Use destructuring assignment to pass an object as function parameters:
	const obj = { a = 1, b = 2, c = 3};
	function ({a, b}) {
	    return a + b;
	}

Objective literal using object property shorthand
	const getMousePosition = (x, y) => ({ x, y}); 
	//instead of { x : x, y : y}

EXPORTING & IMPORTING MODULES
export { function1, function2, ... }
OR
export const function1 = function(a, b) { return a + b }

import { function1, function2, ... } from './file.js';
import * as myModule from './file.js'; // myModule will become an object which contains all exports

export default → used if only one value is being exported from a file or to create a fallback value for a file or module. Can't be used with var, let, or const. To import a default export (without curly brackets): import function1 from './file.js';

PROMISE
You promise to do something, and when the task completes, you either fulfill your promise or fail to do so. It takes a functions as it's argument, with two parameters - resolve and reject. It has three states: pending, fulfilled, and rejected.

	const myPromise = new Promise((resolve, reject) => {
	    if(condition) {
	        resolve('Promise  was fulfilled'); //used when promise succeeded
	    } else {
	        reject('Promise was rejected'); //used when promise failed
	    }
	}).then(result => {
	    //do something with the result. It's executed immediately after your promise is fulfilled with resolve. result comes from the argument given to the resolve method.
	}).catch(error => {
	    //used when promise was rejected. It's executed immediately after a promise reject method is called. error is the argument passed into the reject method.
	});


ARRAYS
.push() → adds a value to the end of array
.unshift() → adds a value to the beginning of array
.pop() → removes the last value and returns it
.shift() → removes the first value and returns it
.splice() → remove any number of consecutive elements from anywhere in an array; (index start, num to remove, element to add)
.slice() → copies a given number of elements to a new array; (index start, index end)

.filter() → filters the array accordingly with a condition
.map() → creates a new array with the results of calling a provided function on every element in the calling array.
.reduce() → executes a reducer function (that you provide) on each element of the array, resulting in a single output value.

...arg → spread operator, can be used where multiple parameters or elements are expected

indexOf() → return the index of specified element

every(), forEach(), map()


const squaredIntegers = arr.filter((value) => value > 0 && Number.isInteger(value)).map(value => value *= value);


OBJECTS
delete myDog.tails → deletes the property of the object

  If you have tabular data, you can use an object to "lookup" values rather than a switch statement or an if/else chain.

.hasOwnProperty() → checks if the property of a given object exists or not

Object.freeze() → freezes an object so is no longer possible to add, update or delete properties from it.

for..in
for (let key in obj) {}

Object.keys() → generate an array which contains all the keys stored in an object.

object.constructor → the property is a reference to the constructor function that created the instance. Better to use instanceof.J



MATH
Math.random() → generates random number from 0 to 1 (exclusive)
Math.floor() → rounds the number down to its nearest whole number

parseInt() → converts string to number
	, radix → specifies the base for the number converted (from 2 [binary] to 36)
